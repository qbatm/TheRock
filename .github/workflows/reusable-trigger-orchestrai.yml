name: Reusable OrchestrAI Trigger

on:
  workflow_call:
    inputs:
      platform:
        description: 'Platform to trigger (linux or windows)'
        required: true
        type: string
      sdk_url_override:
        description: 'Override SDK URL (skips S3 lookup)'
        required: false
        type: string
        default: ''
      pool_type:
        description: 'Jenkins agent pool type'
        required: false
        type: string
        default: 'ucicd_production_hot_machines'
      polling_interval:
        description: 'Polling interval in seconds'
        required: false
        type: number
        default: 300 # Every 5 minutes
      timeout_minutes:
        description: 'Timeout in minutes'
        required: false
        type: number
        default: 240 # 4 hour timeout
    secrets:
      UCICD_USER:
        required: true
      UCICD_TOKEN:
        required: true
  workflow_dispatch:
    inputs:
      platform:
        description: 'Platform to trigger (linux or windows)'
        required: true
        type: choice
        options:
          - linux
          - windows
      sdk_url_override:
        description: 'Override SDK URL (skips S3 lookup)'
        required: false
        type: string
        default: ''
      pool_type:
        description: 'Jenkins agent pool type'
        required: false
        type: string
        default: 'ucicd_production_hot_machines'
      polling_interval:
        description: 'Polling interval in seconds'
        required: false
        type: number
        default: 300 # Every 5 minutes
      timeout_minutes:
        description: 'Timeout in minutes'
        required: false
        type: number
        default: 240 # 4 hour timeout

env:
  JENKINS_URL: "https://ucicd-jenkins.amd.com"
  JENKINS_JOB_PATH: "job/DevOps/job/nm/job/ucicd-production-v1"

jobs:
  # Preprocessing job to generate the matrix of GPU targets
  preprocess:
    name: Generate GPU Matrix
    runs-on: arc-lnx-pub
    outputs:
      matrix: ${{ steps.generate_matrix.outputs.matrix }}
      trigger_count: ${{ steps.generate_matrix.outputs.trigger_count }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Set up Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: '3.12'

      - name: Generate trigger configurations
        id: generate_matrix
        run: |
          echo "Generating OrchestrAI trigger configurations for ${{ inputs.platform }}..."

          # Build the command with optional parameters
          CMD="python build_tools/trigger_orchestrai.py --mode generate --platform ${{ inputs.platform }} --commit-id ${{ github.sha }}"

          # Add SDK URL override if provided
          if [[ -n "${{ inputs.sdk_url_override }}" ]]; then
            CMD="$CMD --sdk-url \"${{ inputs.sdk_url_override }}\""
          fi

          # Add pool type if provided
          if [[ -n "${{ inputs.pool_type }}" ]]; then
            CMD="$CMD --pool-type \"${{ inputs.pool_type }}\""
          fi

          # Add GitHub output file
          CMD="$CMD --github-output $GITHUB_OUTPUT"

          echo "Running: $CMD"
          eval $CMD

          # Read the trigger configs and transform to matrix format
          TRIGGER_CONFIGS=$(grep -oP 'trigger_configs=\K.*' $GITHUB_OUTPUT || echo "[]")

          # Create matrix JSON with include array
          MATRIX=$(echo "$TRIGGER_CONFIGS" | jq -c '{include: .}')
          echo "matrix=${MATRIX}" >> $GITHUB_OUTPUT

          echo "✅ Matrix generated with $(echo "$TRIGGER_CONFIGS" | jq 'length') configurations"

  # Matrix job that triggers each GPU target in parallel
  trigger-orchestrai:
    name: Trigger OrchestrAI (${{ matrix.gpu_tag }})
    needs: preprocess
    runs-on: arc-lnx-pub
    environment: ucicd
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.preprocess.outputs.matrix) }}
    steps:
      - name: Trigger OrchestrAI
        id: trigger
        env:
          UCICD_USER: ${{ secrets.UCICD_USER }}
          UCICD_TOKEN: ${{ secrets.UCICD_TOKEN }}
          JENKINS_TRIGGER_TOKEN: ${{ secrets.UCICD_USER }}
        run: |
          echo "Triggering OrchestrAI for GPU: ${{ matrix.gpu_tag }} on ${{ matrix.platform }}"

          BUILDS_JSON='${{ matrix.builds_json }}'
          echo "BUILDS_JSON: ${BUILDS_JSON}"

          # Extract SDK URL for later use in summary
          SDK_URL='${{ matrix.sdk_url }}'
          echo "sdk_url=${SDK_URL}" >> $GITHUB_OUTPUT

          # URL-encode the parameters using jq
          ENCODED_BUILDS_JSON=$(jq -rn --arg str "${BUILDS_JSON}" '$str|@uri')

          # Trigger the parameterized job using the remote trigger token
          # This bypasses CSRF protection and is the same method the old workflow used
          RESPONSE=$(curl -s -i -X POST \
            --user "${UCICD_USER}:${UCICD_TOKEN}" \
            "${{ env.JENKINS_URL }}/${{ env.JENKINS_JOB_PATH }}/buildWithParameters?token=${JENKINS_TRIGGER_TOKEN}&BUILDS_JSON=${ENCODED_BUILDS_JSON}")

          # Extract the queue URL from Location header
          QUEUE_URL=$(echo "$RESPONSE" | grep -i "^Location:" | awk '{print $2}' | tr -d '\r')

          if [ -z "$QUEUE_URL" ]; then
            echo "::error::Failed to trigger OrchestrAI for ${{ matrix.gpu_tag }}"
            echo "Response:"
            echo "$RESPONSE" | head -30
            exit 1
          fi

          echo "Queue URL: $QUEUE_URL"
          echo "queue_url=${QUEUE_URL}" >> $GITHUB_OUTPUT

      - name: Wait for Build Number
        id: get_build_number
        env:
          UCICD_USER: ${{ secrets.UCICD_USER }}
          UCICD_TOKEN: ${{ secrets.UCICD_TOKEN }}
        run: |
          QUEUE_URL="${{ steps.trigger.outputs.queue_url }}"

          echo "Waiting for OrchestrAI build (${{ matrix.gpu_tag }}) to be assigned..."

          # Poll the queue until we get a build number (max 5 minutes)
          MAX_ATTEMPTS=60
          ATTEMPT=0
          BUILD_NUMBER=""

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            QUEUE_INFO=$(curl -s --user "${UCICD_USER}:${UCICD_TOKEN}" \
              "${QUEUE_URL}api/json")

            # Check if build has started (executable field will be populated) using jq
            BUILD_NUMBER=$(echo "$QUEUE_INFO" | jq -r '.executable.number // empty')

            if [ -n "$BUILD_NUMBER" ]; then
              echo "Build number: $BUILD_NUMBER"
              break
            fi

            # Check if cancelled using jq
            CANCELLED=$(echo "$QUEUE_INFO" | jq -r '.cancelled // false')

            if [ "$CANCELLED" = "true" ]; then
              echo "::error::OrchestrAI build (${{ matrix.gpu_tag }}) was cancelled in queue"
              exit 1
            fi

            ATTEMPT=$((ATTEMPT + 1))
            echo "Waiting for build to start (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
            sleep 5
          done

          if [ -z "$BUILD_NUMBER" ]; then
            echo "::error::Timed out waiting for OrchestrAI build number (${{ matrix.gpu_tag }})"
            exit 1
          fi

          echo "build_number=${BUILD_NUMBER}" >> $GITHUB_OUTPUT

      - name: Poll OrchestrAI for Completion
        id: poll
        env:
          UCICD_USER: ${{ secrets.UCICD_USER }}
          UCICD_TOKEN: ${{ secrets.UCICD_TOKEN }}
          BUILD_NUMBER: ${{ steps.get_build_number.outputs.build_number }}
        run: |
          BUILD_URL="${{ env.JENKINS_URL }}/${{ env.JENKINS_JOB_PATH }}/${BUILD_NUMBER}"
          echo "Polling OrchestrAI build: ${BUILD_NUMBER} (${{ matrix.gpu_tag }})"

          POLLING_INTERVAL=${{ inputs.polling_interval }}
          TIMEOUT_SECONDS=$(( ${{ inputs.timeout_minutes }} * 60 ))
          START_TIME=$(date +%s)

          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))

            if [ $ELAPSED -ge $TIMEOUT_SECONDS ]; then
              echo "::error::Timeout waiting for OrchestrAI (${{ matrix.gpu_tag }}) to complete"
              exit 1
            fi

            BUILD_INFO=$(curl -s --user "${UCICD_USER}:${UCICD_TOKEN}" \
              "${BUILD_URL}/api/json")

            # Check if build is still running using jq
            BUILDING=$(echo "$BUILD_INFO" | jq -r 'if .building == false then "false" else "true" end')

            if [ "$BUILDING" = "false" ]; then
              echo "OrchestrAI build completed!"

              # Extract result using jq
              RESULT=$(echo "$BUILD_INFO" | jq -r '.result // "UNKNOWN"')

              # Extract duration and convert to seconds using jq
              DURATION_MS=$(echo "$BUILD_INFO" | jq -r '.duration // 0')
              DURATION_SEC=$((DURATION_MS / 1000))

              echo "result=${RESULT}" >> $GITHUB_OUTPUT
              echo "duration=${DURATION_SEC}s" >> $GITHUB_OUTPUT
              break
            fi

            echo "Build still running (${{ matrix.gpu_tag }})... (elapsed: ${ELAPSED}s)"
            sleep $POLLING_INTERVAL
          done

      - name: Fetch Test Results
        id: test_results
        env:
          UCICD_USER: ${{ secrets.UCICD_USER }}
          UCICD_TOKEN: ${{ secrets.UCICD_TOKEN }}
          BUILD_NUMBER: ${{ steps.get_build_number.outputs.build_number }}
        run: |
          BUILD_URL="${{ env.JENKINS_URL }}/${{ env.JENKINS_JOB_PATH }}/${BUILD_NUMBER}"
          echo "Fetching test results from OrchestrAI build ${BUILD_NUMBER}..."

          # Try to fetch the test results JSON artifact from Jenkins workspace
          # The file is written as ucicd_test_results.json by the pipeline
          TEST_RESULTS=$(curl -s --user "${UCICD_USER}:${UCICD_TOKEN}" \
            "${BUILD_URL}/artifact/ucicd_test_results.json" 2>/dev/null || echo "")

          if [ -n "$TEST_RESULTS" ] && echo "$TEST_RESULTS" | jq -e '.summary' > /dev/null 2>&1; then
            echo "✅ Test results fetched successfully"

            # Extract test summary fields
            PLATFORM=$(echo "$TEST_RESULTS" | jq -r '.summary.environment.THEROCK_PLATFORM // "N/A"')
            GPU_ARCH=$(echo "$TEST_RESULTS" | jq -r '.summary.environment.THEROCK_GPU_ARCH_PATTERN // "N/A"')
            TOTAL_TESTS=$(echo "$TEST_RESULTS" | jq -r '.summary.total_tests // "N/A"')
            PASSED=$(echo "$TEST_RESULTS" | jq -r '.summary.passed // "N/A"')
            FAILED=$(echo "$TEST_RESULTS" | jq -r '.summary.failed // "N/A"')
            SKIPPED=$(echo "$TEST_RESULTS" | jq -r '.summary.skipped // "N/A"')
            ERROR=$(echo "$TEST_RESULTS" | jq -r '.summary.error // "N/A"')
            UNKNOWN=$(echo "$TEST_RESULTS" | jq -r '.summary.unknown // "N/A"')

            # Output for use in summary step
            echo "has_results=true" >> $GITHUB_OUTPUT
            echo "platform=${PLATFORM}" >> $GITHUB_OUTPUT
            echo "gpu_arch=${GPU_ARCH}" >> $GITHUB_OUTPUT
            echo "total_tests=${TOTAL_TESTS}" >> $GITHUB_OUTPUT
            echo "passed=${PASSED}" >> $GITHUB_OUTPUT
            echo "failed=${FAILED}" >> $GITHUB_OUTPUT
            echo "skipped=${SKIPPED}" >> $GITHUB_OUTPUT
            echo "error=${ERROR}" >> $GITHUB_OUTPUT
            echo "unknown=${UNKNOWN}" >> $GITHUB_OUTPUT
          else
            echo "⚠️ Test results not available or invalid format"
            echo "has_results=false" >> $GITHUB_OUTPUT
          fi

      - name: Write Job Summary
        run: |
          RESULT="${{ steps.poll.outputs.result }}"
          SDK_URL="${{ steps.trigger.outputs.sdk_url }}"
          GPU_TAG="${{ matrix.gpu_tag }}"
          PLATFORM="${{ matrix.platform }}"

          # Write summary with GPU target context
          echo "### OrchestrAI Test Results - ${GPU_TAG} (${PLATFORM})" >> $GITHUB_STEP_SUMMARY

          # Add test results table if available
          if [ "${{ steps.test_results.outputs.has_results }}" = "true" ]; then
            echo "| Platform | GPU Arch | Total Tests | Passed | Failed | Skipped | Error | Unknown |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|----------|-------------|--------|--------|---------|-------|---------|" >> $GITHUB_STEP_SUMMARY
            echo "| ${{ steps.test_results.outputs.platform }} | ${{ steps.test_results.outputs.gpu_arch }} | ${{ steps.test_results.outputs.total_tests }} | ${{ steps.test_results.outputs.passed }} | ${{ steps.test_results.outputs.failed }} | ${{ steps.test_results.outputs.skipped }} | ${{ steps.test_results.outputs.error }} | ${{ steps.test_results.outputs.unknown }} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "_Test results not available_" >> $GITHUB_STEP_SUMMARY
          fi

          # Add SDK URL link
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**SDK URL:** ${SDK_URL}" >> $GITHUB_STEP_SUMMARY

          # Fail the workflow if OrchestrAI job failed
          if [ "$RESULT" != "SUCCESS" ]; then
            echo "::error::OrchestrAI (${GPU_TAG}) finished with result: ${RESULT}"
            exit 1
          fi
